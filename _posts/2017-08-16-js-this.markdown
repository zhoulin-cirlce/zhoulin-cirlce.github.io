---
layout:     post
title:      "从指向看JavaScript"
subtitle:   "Keynote: JavaScript Modularization Journey"
date:       2017-08-16
author:     "zhoulin-cirlce"
header-img: "img/post-bg-js-version.jpg"
tags:
    - 前端开发
    - JavaScript
---

摘要: this?原型/原型链？继承？闭包？我们不妨从指向这个概念去理解JavaScript中的这些点！
### 前言
开写前大家先来理解一下指向：指向，即目标方向、所对的方位。
很多人刚刚接触前端甚至一些“老”前端都经常会在JavaScript中所谓的难点，如this，原型，继承，闭包等这些概念中迷失了自我。接下来这篇文章会把我自己对于JavaScript中这些点通过指向的概念做个总结并分享给大家，希望可以帮助大家更好的了解这些所谓的难点。
#### 一、this
this是什么？其实它本身就是一种指向。this指向可以分为以下几种情况

* 普通调用，this指向为调用者
* call/apply调用，this指向为当前thisArg参数
* 箭头函数，this指向为当前函数的this指向
这个怎么理解呢？接下来我会一一做解析。

#### 1、普通调用
通俗理解一下，就是谁调用，则this便指向谁。这里又大致分为几种情况，分别为

####　1.1、对象方法的调用
即某方法为某对象上的一个属性的属性，正常情况当改方法被调用的时候，this的指向则是挂载该方法的对象。废话不多说，直接看代码可能会更好的理解。

```js
var obj={
    a:'this is obj',
    test:function(){
        console.log(this.a);
    }
}
obj.test(); //this-->obj
```
#### 1.2、“单纯”函数调用
即该函数为自己独立的函数，而不是挂载到对象上的属性（window除外），也不会被当成构造函数来使用，而仅仅是当成函数来使用，此时的this指向则是window对象。例子如下

```js
var a='this is window';
function test(){
    console.log(this.a);
}
test(); //this-->window
```
这个我们来理解一下，其实也很简单，我们都知道，window对象是全局对象。其实整个代码块等同于

```js
 window.a='this is window';
 window.test=function test(){
     console.log(this.a);
     //此时window为调用者，即this会指向window
 }
 window.test();
```
#### 1.3、构造函数调用
即该函数被当成构造函数来调用，此时的this指向该构造器函数的实例对象。
我们来看一个例子，先上一个属于第二种情况的例子

```js
 function test(){
     this.a='this is test';
     console.log(this.a);
     console.log(this);
 }
 test();
 //this is test    this---->window
 //Window {}
```
按照上面的来理解，此时的this的确指向window对象，但是如果我换种形式，将其换成构造函数来调用呢，结果又会如何呢，直接上代码

```js
function Test(){
    this.a='this is test';
    console.log(this.a);
    console.log(this);
}
var test= new Test();
//this is test    this--->new Test()
//Test {a:'this is test'}
```

OK，好像的确没有问题了，此时的this的确指向了该构造函数的实例对象。具体这里的一些解释后面我会在原型链继承里面详细讲解。

#### 2、call/apply调用
#### 2.1、call调用 

call方法形式，fun.call(thisArg[, arg1[, arg2[, ...]]])
* thisArg，当前this指向
* arg1[, arg2[, ...]]，指定的参数列表
详细介绍请猛戳[MDN](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call)
示例代码如下

```js
function Test () {
  this.a = 'this is test';
  console.log(this.a);
  console.log(this);
}
function Test2 () {
  Test.call(this)
}
var test = new Test2();
// this is test
// Test2 {a: 'this is test'}
```

2.2、apply调用
和call类似，唯一的一个明显区别就是call参数为多个，apply参数则为两个，第二个参数为数组或类数组形式， fun.apply(thisArg, [argsArray])

thisArg，当前this指向
一个数组或者类数组对象，其中的数组元素将作为单独的参数传给fun函数
详细介绍请猛戳MDN

但是终究apply里面的数组参数会转变为call方法的参数形式，然后去走下面的步骤，这也是为什么call执行速度比apply快。这边详情有篇文章有介绍，点击链接。

另外，提及到call/apply，怎么能不提及一下bind呢，bind里面的this指向，会永远指向bind到的当前的thisArg，即context上下文环境参数不可重写。这也是为什么a.bind(b).call(c)，最终的this指向会是b的原因。至于为什么，其实就是bind实现实际上是通过闭包，并且配合call/apply进行实现的。具体的请参考bind MDN里面的用法及 Polyfill实现。
